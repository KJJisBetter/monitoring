#include "system_data.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysinfo.h>
#include <unistd.h>


// in all this funcs I used copilot to get the values I needed to get from the files to get the data.
// even tho I still had to open the file myself to see what I needed sometimes.

int cpu_data() {
    //TODO: Improve this function to use more accurate CPU statistics. similar to network_data().
    //done
    static unsigned long long prev_user = 0, prev_nice = 0, prev_system = 0, prev_idle = 0;
    static unsigned long long prev_iowait = 0, prev_irq = 0, prev_softirq = 0, prev_steal = 0;

    FILE* file = fopen("/proc/stat", "r");
    if (file == NULL) {
        printf("Error opening /proc/stat\n");
        return -1;
    }

    char line[256];
    unsigned long long user, nice, system, idle, iowait, irq, softirq, steal;
    unsigned long long total_idle, total_system, total_virtual, total;
    double total_cpu_usage;

    if (fgets(line, sizeof(line), file)) {
        if (strncmp(line, "cpu ", 4) == 0) {
            sscanf(line, "cpu  %llu %llu %llu %llu %llu %llu %llu %llu",
                   &user, &nice, &system, &idle, &iowait, &irq, &softirq, &steal);

            unsigned long long prev_total_idle = prev_idle + prev_iowait;
            unsigned long long total_idle = idle + iowait;

            unsigned long long prev_total = (prev_user + prev_nice + prev_system + prev_idle + prev_iowait + prev_irq + prev_softirq + prev_steal);
            unsigned long long total = (user + nice + system + idle + iowait + irq + softirq + steal);

            unsigned long long total_delta = total - prev_total;
            unsigned long long idle_delta = total_idle - prev_total_idle;

            total_cpu_usage = 100.0 * (total_delta - idle_delta) / total_delta;
            printf("Total CPU Usage: %.2f%%\n", total_cpu_usage);

            prev_user = user;
            prev_nice = nice;
            prev_system = system;
            prev_idle = idle;
            prev_iowait = iowait;
            prev_irq = irq;
            prev_softirq = softirq;
            prev_steal = steal;
        }
    }

    fclose(file);

    return (int)total_cpu_usage;
}



int memory_data() {
    //TODO: Improve this function to use more accurate memory statistics. similar to network_data().
    // done
    FILE* file = fopen("/proc/meminfo", "r");
    if (file == NULL) {
        printf("Error opening /proc/meminfo\n");
        return -1;
    }

    unsigned long memTotal, memFree, memAvailable, buffers, cached;
    char buffer[256];

    while (fgets(buffer, sizeof(buffer), file)) {
        if (sscanf(buffer, "MemTotal: %lu kB", &memTotal) == 1) continue;
        if (sscanf(buffer, "MemFree: %lu kB", &memFree) == 1) continue;
        if (sscanf(buffer, "MemAvailable: %lu kB", &memAvailable) == 1) continue;
        if (sscanf(buffer, "Buffers: %lu kB", &buffers) == 1) continue;
        if (sscanf(buffer, "Cached: %lu kB", &cached) == 1) continue;
    }
    fclose(file);

    unsigned long used = memTotal - memFree - buffers - cached;
    double memory_usage = 100.0 * used / memTotal;

    return (int)memory_usage;
}

// ! after making the other 2 funcs copilot knew exactly what I wanted to do next. Even this comment..... scary stuff.
// ! I'm not sure if I should be happy or scared. I'm happy that it's so smart but scared that it's so smart. <-this comment was also generated by copilot.
// ! anyway it got it wrong it wont copile life aint that easy.
int diskio_data() {
    const char* target_device = "sda";
    static unsigned long long prev_io_time = 0;

    // command to see the data I can get: -> cat /proc/diskstats
    FILE* file = fopen("/proc/diskstats", "r");
    if (file == NULL) {
        printf("Error opening /proc/diskstats\n");
        return -1;
    }

    char buffer[256];
    unsigned long long read_time = 0, write_time = 0, io_time = 0;
    double io_percentage = 0.0;

    while (fgets(buffer, sizeof(buffer), file)) {
        int major, minor;
        char device[256];
        unsigned long long reads, reads_merged, sectors_read, writes, writes_merged, sectors_written, io_in_progress, io_time_weighted;

        if (sscanf(buffer, "%d %d %s %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
                   &major, &minor, device,
                   &reads, &reads_merged, &sectors_read, &read_time,
                   &writes, &writes_merged, &sectors_written, &write_time,
                   &io_in_progress, &io_time, &io_time_weighted) >= 14) {
            if (strcmp(device, target_device) == 0) {
                io_time = read_time + write_time;
                unsigned long long io_delta = io_time - prev_io_time;
                unsigned long long interval_ms = 1000; // Assuming 1-second interval

                io_percentage = 100.0 * io_delta / interval_ms;
                printf("Disk I/O Usage: %.2f%%\n", io_percentage);

                prev_io_time = io_time;
                break;
            }
        }
    }

    fclose(file);

    return (int)io_percentage;
}


// ! again copilot knew what I wanted to do next. It's like it's reading my mind. <-this comment was also generated by copilot.
// ! scary stuff.....

struct NetworkData {
    unsigned long long bytes_received;
    unsigned long long packets_received;
    unsigned long long bytes_transmitted;
    unsigned long long packets_transmitted;
};

// most this network stuff was done using chatgpt. I had it working but I couldnt figure out how to separate net_in and net_out to the api..
void read_network_data(struct NetworkData* data) {
    FILE* file = fopen("/proc/net/dev", "r");
    if (file == NULL) {
        perror("Error opening /proc/net/dev");
        return;
    }

    char buffer[256];
    while (fgets(buffer, sizeof(buffer), file)) {
        if (strstr(buffer, "Inter-") || strstr(buffer, " face")) {
            continue;
        }

        char interface[32];
        unsigned long long bytes_received, packets_received, bytes_transmitted, packets_transmitted;

        if (sscanf(buffer, "%s %llu %llu %llu %llu",
                   interface,
                   &bytes_received, &packets_received,
                   &bytes_transmitted, &packets_transmitted) == 5) {
            data->bytes_received = bytes_received;
            data->packets_received = packets_received;
            data->bytes_transmitted = bytes_transmitted;
            data->packets_transmitted = packets_transmitted;
            break;
        }
    }

    fclose(file);
}

double network_data(int interval, struct NetworkUsage* usage) {
    struct NetworkData stats_start, stats_end;

    // I dont like using stuff  if I dont know what it does.
    // I asked gpt what it does and I still dont understand very well. But I think it just sets the value of the struct to 0. So when needed later it will be the correct value.
    // chatgpt: By initializing the structures to zero, you ensure that any fields not explicitly set later will be zero.
    memset(&stats_start, 0, sizeof(struct NetworkData));
    memset(&stats_end, 0, sizeof(struct NetworkData));

    //calling another function to get the network data.
    read_network_data(&stats_start);


    sleep(interval);

    //not once but twice. I would have never thought of this.
    //But it makes sense. it makes the code more readable and easier to understand.
    read_network_data(&stats_end);


    unsigned long long net_in = stats_end.bytes_received - stats_start.bytes_received;
    unsigned long long net_out = stats_end.bytes_transmitted - stats_start.bytes_transmitted;


    double net_in_kb = net_in / 1024.0 / interval;
    double net_out_kb = net_out / 1024.0 / interval;

    printf("Network In: %.2f KiB/s Network Out: %.2f KiB/s\n", net_in_kb, net_out_kb);

    // I would have never come up with this.
    usage->inbound = net_in_kb;
    usage->outbound = net_out_kb;

    // funny how it left my attempt at getting both values even tho I knew thats not the way to do it.
    // this would just add both values and return it. but I wanted to see if it at least got one value. to see the chart.
    return net_in_kb + net_out_kb;
}

// !compile command for a shared library:-> gcc -shared -o libsystem_data.so -fPIC system_data.c